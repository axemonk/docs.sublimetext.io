import{_ as e,c as a,o,a4 as t}from"./chunks/framework.DTvtauHd.js";const f=JSON.parse('{"title":"Plugins","description":"","frontmatter":{"title":"Plugins"},"headers":[],"relativePath":"reference/plugins.md","filePath":"reference/plugins.md","lastUpdated":1713130727000}'),n={name:"reference/plugins.md"},i=t('<h1 id="plugins" tabindex="-1">Plugins <a class="header-anchor" href="#plugins" aria-label="Permalink to &quot;Plugins&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">See Also</p><p><a href="./../reference/python_api.html">API Reference</a> : More information on the Python API.</p></div><p>Plugins are Python scripts subclassing any of the <code>*Command</code> or <code>*Listener</code> classes from the <code>sublime_plugin</code> module.</p><h2 id="where-to-store-plugins" tabindex="-1">Where to Store Plugins <a class="header-anchor" href="#where-to-store-plugins" aria-label="Permalink to &quot;Where to Store Plugins&quot;">​</a></h2><p>Sublime Text will look for plugins in these places:</p><ul><li><code>Packages</code></li><li><code>Packages/&lt;pkg_name&gt;</code></li><li><code>.sublime-package</code> files</li></ul><p>Plugin files nested deeper in <code>Packages</code> won&#39;t be loaded.</p><p>All plugins should live inside a folder of their own and not directly under <code>Packages</code>. This will spare you confusions when Sublime Text attempts to sort packages for loading.</p><h2 id="conventions-for-command-names" tabindex="-1">Conventions for Command Names <a class="header-anchor" href="#conventions-for-command-names" aria-label="Permalink to &quot;Conventions for Command Names&quot;">​</a></h2><p>By convention, Sublime Text command class names are suffixed with <code>Command</code> and written as <code>NamesLikeThisCommand</code>.</p><p>However, command names are automatically transformed from <code>NamesLikeThisCommand</code> to <code>name_like_this</code>. Thus, <code>ExampleCommand</code> would become <code>example</code>, and <code>AnotherExampleCommand</code> would become <code>another_example</code>.</p><p>In names for classes defining commands, use <code>NameLikeThisCommand</code>. To call a command from the API, use the standardized <code>name_like_this</code>.</p><h2 id="types-of-commands" tabindex="-1">Types of Commands <a class="header-anchor" href="#types-of-commands" aria-label="Permalink to &quot;Types of Commands&quot;">​</a></h2><ul><li><code>sublime_plugin.ApplicationCommand</code></li><li><code>sublime_plugin.WindowCommand</code></li><li><code>sublime_plugin.TextCommand</code></li></ul><p>Instances of <code>WindowCommand</code> have a <code>.window</code> attribute pointing to the window instance that created them. Similarly, instances of <code>TextCommand</code> have a <code>.view</code> attribute. <code>ApplicationCommand</code> instances don&#39;t have either.</p><h3 id="shared-traits-for-commands" tabindex="-1">Shared Traits for Commands <a class="header-anchor" href="#shared-traits-for-commands" aria-label="Permalink to &quot;Shared Traits for Commands&quot;">​</a></h3><p>All commands must implement a <code>.run()</code> method.</p><p>All commands may additionally provide methods to change their visibility, enabled state, default caption in menus, or even their name (discouraged).</p><h2 id="how-to-call-commands-from-the-api" tabindex="-1">How to Call Commands from the API <a class="header-anchor" href="#how-to-call-commands-from-the-api" aria-label="Permalink to &quot;How to Call Commands from the API&quot;">​</a></h2><p>Depending on the type of command, use a reference to a <code>View</code> or a <code>Window</code> and call <code>&lt;object&gt;.run_command(&#39;command_name&#39;)</code>. In addition to the command&#39;s name, <code>.run_command</code> accepts a dictionary whose keys are the names of valid parameters for said command:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.run_command(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Tempus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Irreparabile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Fugit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>All user-provided arguments to commands must JSON-serializable. This includes strings, integers, floats, booleans, <code>None</code>, and the recursive list and dict types. Mapping keys must be strings.</p><h2 id="text-commands-and-the-edit-object" tabindex="-1">Text Commands and the <code>edit</code> Object <a class="header-anchor" href="#text-commands-and-the-edit-object" aria-label="Permalink to &quot;Text Commands and the `edit` Object&quot;">​</a></h2><p>Text commands receive an <code>edit</code> object passed to them by Sublime Text.</p><p>All actions done within an <code>edit</code> are grouped as a single undo action. Callbacks such as <code>on_modified()</code> and <code>on_selection_modified()</code> are called when the most outer edit operation is finished.</p><p>The <code>edit</code> object&#39;s life time is solely managed by Sublime Text internally. Plugin authors must ensure to perform all editing operations within the <code>run()</code> method of text commands so that macros and repeating commands work as expected.</p><h2 id="responding-to-events" tabindex="-1">Responding to Events <a class="header-anchor" href="#responding-to-events" aria-label="Permalink to &quot;Responding to Events&quot;">​</a></h2><p>Any subclass of <code>EventListener</code> will be able to respond to events. You cannot make a class derive both from <code>EventListener</code> and from any other type of command.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Expensive operations in event listeners can cause Sublime Text to become unresponsive, especially in events triggered frequently, like <code>on_modified()</code> and <code>on_selection_modified()</code>. Be careful of how much work is done in these and don&#39;t implement events you don&#39;t need, even if they just <code>pass</code>.</p></div><h2 id="sublime-text-and-the-python-standard-library" tabindex="-1">Sublime Text and the Python Standard Library <a class="header-anchor" href="#sublime-text-and-the-python-standard-library" aria-label="Permalink to &quot;Sublime Text and the Python Standard Library&quot;">​</a></h2><p>The most significant omission from the default distribution is the <code>tkinter</code> module. Otherwise, you can access the entire Python standard library for the Python version Sublime Text ships with.</p><h2 id="automatic-plugin-reload" tabindex="-1">Automatic Plugin Reload <a class="header-anchor" href="#automatic-plugin-reload" aria-label="Permalink to &quot;Automatic Plugin Reload&quot;">​</a></h2><p>Sublime Text will reload topmost Python modules as they change (perhaps because you are editing a <em>.py</em> file within <em>Packages</em>). By contrast, Python subpackages won&#39;t be reloaded automatically, and this can lead to confusion while you&#39;re developing plugins. Generally speaking, it&#39;s best to restart Sublime Text after you&#39;ve made changes to plugin files, so all changes can take effect.</p>',33),s=[i];function d(l,c,r,m,h,p){return o(),a("div",null,s)}const g=e(n,[["render",d]]);export{f as __pageData,g as default};
