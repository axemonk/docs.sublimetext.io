(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{476:function(t,e,a){"use strict";a.r(e);var s=a(18),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Syntax definitions make Sublime Text aware of programming and markup languages.\nMost noticeably, they work together with colors to provide syntax highlighting.\nSyntax definitions define "),a("em",[t._v("scopes")]),t._v(" that divide the text in a buffer into named\nregions. Several editing features in Sublime Text make extensive use of\nthis fine-grained contextual information.")]),t._v(" "),a("p",[t._v("Essentially, syntax definitions consist of regular expressions used to find\ntext, as well as more or less arbitrary, dot-separated strings called "),a("em",[t._v("scopes")]),t._v("\nor "),a("em",[t._v("scope names")]),t._v(". For every occurrence of a given regular expression, Sublime\nText gives the matching text its corresponding "),a("em",[t._v("scope name")]),t._v(".")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("Deprecation Notice")]),t._v(" "),a("p",[t._v("For Sublime Text 3 (Build 3084),\na new syntax definition format has been added\nwith the "),a("code",[t._v(".sublime-syntax")]),t._v(" extension.")]),t._v(" "),a("p",[t._v("It is highly encouraged to be used\nin favor of the legacy TextMate format\ndescribed in this document,\nunless compatibility with older versions\nor other editors is desired.")]),t._v(" "),a("p",[t._v("Documentation is available\nat the "),a("a",{attrs:{href:"https://www.sublimetext.com/docs/3/syntax.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("official documentation"),a("OutboundLink")],1),t._v(".")])]),t._v(" "),a("div",{staticClass:"custom-block seealso"},[a("p",{staticClass:"custom-block-title"},[t._v("See Also")]),a("p",[a("RouterLink",{attrs:{to:"/reference/syntaxdefs_legacy.html"}},[t._v("Reference for TextMate Syntax Definitions")])],1)]),a("h2",{attrs:{id:"prerequisites"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites"}},[t._v("#")]),t._v(" Prerequisites")]),t._v(" "),a("p",[t._v("In order to follow this tutorial, you will need to install\n"),a("a",{attrs:{href:"https://github.com/SublimeText/PackageDev",target:"_blank",rel:"noopener noreferrer"}},[t._v("PackageDev"),a("OutboundLink")],1),t._v(', a package\nintended to ease the creation of new syntax definitions for Sublime\nText. Follow the installation notes in the "Getting Started" section of\nthe readme.')]),t._v(" "),a("h2",{attrs:{id:"file-format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#file-format"}},[t._v("#")]),t._v(" File format")]),t._v(" "),a("p",[t._v("Sublime Text uses "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Property_list",target:"_blank",rel:"noopener noreferrer"}},[t._v("property list"),a("OutboundLink")],1),t._v("\n(Plist) files to store syntax definitions. However, because editing XML files is\na cumbersome task, we'll use "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/YAML",target:"_blank",rel:"noopener noreferrer"}},[t._v("YAML"),a("OutboundLink")],1),t._v(" instead\nand convert it to Plist format afterwards. This is where the "),a("Term",{attrs:{term:"PackageDev"}}),t._v(" package\n(mentioned above) comes in.")],1),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("If you experience unexpected errors during this tutorial, chances are\n"),a("Term",{attrs:{term:"PackageDev"}}),t._v(" or YAML is to blame. Don't immediately think your problem is\ndue to a bug in Sublime Text.")],1)]),t._v(" "),a("p",[t._v("By all means, do edit the Plist files by hand if you prefer to work in\nXML, but always keep in mind their differing needs in regards to escape\nsequences, many XML tags etc.")]),t._v(" "),a("h2",{attrs:{id:"scopes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scopes"}},[t._v("#")]),t._v(" Scopes")]),t._v(" "),a("p",[t._v("Scopes are a key concept in Sublime Text. Essentially, they are named\ntext regions in a buffer. They don't do anything by themselves, but\nSublime Text peeks at them when it needs contextual information.")]),t._v(" "),a("p",[t._v("For instance, when you trigger a snippet, Sublime Text checks the scope\nbound to the snippet and looks at the caret's position in the file. If\nthe caret's current position matches the snippet's scope selector,\nSublime Text fires it off. Otherwise, nothing happens.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Info")]),t._v(" "),a("p",[t._v("There's a slight difference between "),a("em",[t._v("scopes")]),t._v(" and "),a("em",[t._v("scope selectors")]),t._v(": Scopes\nare the names defined in a syntax definition, while scope selectors are used\nin items like snippets and key bindings to target scopes. When creating a\nnew syntax definition, you care about scopes; when you want to constrain a\nsnippet to a certain scope, you use a scope selector.")])]),t._v(" "),a("p",[t._v("Scopes can be nested to allow for a high degree of granularity. You can drill\ndown the hierarchy very much like with CSS selectors. For instance, thanks to\nscope selectors, you could have a key binding activated only within single\nquoted strings in Python source code, but not inside single quoted strings in\nany other language.")]),t._v(" "),a("p",[t._v("Sublime Text inherits the idea of scopes from Textmate, a text editor for Mac.\n"),a("a",{attrs:{href:"https://manual.macromates.com/en/scope_selectors",target:"_blank",rel:"noopener noreferrer"}},[t._v("Textmate's online manual"),a("OutboundLink")],1),t._v(" contains further information about scope selectors\nthat's useful for Sublime Text users too. In particular, Color Schemes make\nextensive use of scopes to style every aspect of a language in the desired\ncolor.")]),t._v(" "),a("h2",{attrs:{id:"how-syntax-definitions-work"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-syntax-definitions-work"}},[t._v("#")]),t._v(" How Syntax Definitions Work")]),t._v(" "),a("p",[t._v("At their core, syntax definitions are arrays of regular expressions\npaired with scope names. Sublime Text will try to match these patterns\nagainst a buffer's text and attach the corresponding scope name to all\noccurrences. These pairs of regular expressions and scope names are\nknown as "),a("em",[t._v("rules")]),t._v(".")]),t._v(" "),a("p",[t._v("Rules are applied in order, one line at a time. Rules are applied in the\nfollowing order:")]),t._v(" "),a("ol",[a("li",[t._v("The rule that matches at the first position in a line")]),t._v(" "),a("li",[t._v("The rule that comes first in the array")])]),t._v(" "),a("p",[t._v("Each rule consumes the matched text region, which therefore will be\nexcluded from the next rule's matching attempt (save for a few\nexceptions). In practical terms, this means that you should take care to\ngo from more specific rules to more general ones when you create a new\nsyntax definition. Otherwise, a greedy regular expression might swallow\nparts you'd like to have styled differently.")]),t._v(" "),a("p",[t._v("Syntax definitions from separate files can be combined, and they can be\nrecursively applied too.")]),t._v(" "),a("h2",{attrs:{id:"your-first-syntax-definition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#your-first-syntax-definition"}},[t._v("#")]),t._v(" Your First Syntax Definition")]),t._v(" "),a("p",[t._v("By way of example, let's create a syntax definition for Sublime Text\nsnippets. We'll be styling the actual snippet content, not the whole\n"),a("code",[t._v(".sublime-snippet")]),t._v(" file.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("Since syntax definitions are primarily used to enable syntax highlighting,\nwe'll use the phrase "),a("em",[t._v("to style")]),t._v(" to mean "),a("em",[t._v("to break down a source code file\ninto scopes")]),t._v(". Keep in mind, however, that colors are a different thing from\nsyntax definitions and that scopes have many more uses besides syntax\nhighlighting.")])]),t._v(" "),a("p",[t._v("Here are the elements we want to style in a snippet:")]),t._v(" "),a("ul",[a("li",[t._v("Variables ("),a("code",[t._v("$PARAM1")]),t._v(", "),a("code",[t._v("$USER_NAME")]),t._v("\\ ...)")]),t._v(" "),a("li",[t._v("Simple fields ("),a("code",[t._v("$0")]),t._v(", "),a("code",[t._v("$1")]),t._v("\\ ...)")]),t._v(" "),a("li",[t._v("Complex fields with placeholders ("),a("code",[t._v("${1:Hello}")]),t._v(")")]),t._v(" "),a("li",[t._v("Nested fields ("),a("code",[t._v("${1:Hello ${2:World}!}")]),t._v(")")]),t._v(" "),a("li",[t._v("Escape sequences ("),a("code",[t._v("\\$")]),t._v(", "),a("code",[t._v("\\<")]),t._v(", …)")]),t._v(" "),a("li",[t._v("Illegal sequences ("),a("code",[t._v("$")]),t._v(", "),a("code",[t._v("<")]),t._v(", "),a("code",[t._v("\\")]),t._v(", …)")])]),t._v(" "),a("p",[t._v("Here are the elements we don't want to style because they are too complex for\nthis example:")]),t._v(" "),a("ul",[a("li",[t._v("Variable Substitution ("),a("code",[t._v("${1/Hello/Hi/g}")]),t._v(")")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("Before continuing, make sure you've installed the "),a("Term",{attrs:{term:"PackageDev"}}),t._v(" package as\nexplained above.")],1)]),t._v(" "),a("h2",{attrs:{id:"creating-a-new-syntax-definition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-new-syntax-definition"}},[t._v("#")]),t._v(" Creating A New Syntax Definition")]),t._v(" "),a("p",[t._v("To create a new syntax definition, follow these steps:")]),t._v(" "),a("ol",[a("li",[t._v("Go to "),a("strong",[t._v("Tools | Packages | Package Development | New Syntax\nDefinition")])]),t._v(" "),a("li",[t._v("Save the new file in your "),a("code",[t._v("Packages/User")]),t._v(" folder as a "),a("code",[t._v(".YAML-tmLanguage")]),t._v(" file.")])]),t._v(" "),a("p",[t._v("You now should see a file like this:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [PackageDev] target_format: plist, ext: tmLanguage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Syntax Name\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scopeName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" source.syntax_name\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fileTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("uuid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0da65be4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("5aac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("4b6f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("8071"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("1aadb970b8d9\n\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("p",[t._v("Let's examine the key elements.")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("name")]),a("br"),t._v("\nThe name that Sublime Text will display in the syntax definition\ndrop-down list. Use a short, descriptive name. Typically, you will\nuse the name of the programming language you are creating the syntax\ndefinition for.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("scopeName")]),a("br"),t._v("\nThe topmost scope for this syntax definition. It takes the form\n"),a("code",[t._v("source.<lang_name>")]),t._v(" or "),a("code",[t._v("text.<lang_name>")]),t._v(". For programming\nlanguages, use "),a("code",[t._v("source")]),t._v(". For markup and everything else, use "),a("code",[t._v("text")]),t._v(".")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("fileTypes")]),a("br"),t._v("\nThis is a list of file extensions (without the leading dot). When\nopening files of these types, Sublime Text will automatically\nactivate this syntax definition for them.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("uuid")]),a("br"),t._v("\nThis is a unique identifier for this syntax definition. Each new\nsyntax definition gets its own uuid. Even though Sublime Text itself\nignores it, don't modify this.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("patterns")]),a("br"),t._v("\nA container for your patterns.")])])]),t._v(" "),a("p",[t._v("For our example, fill the template with the following information:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [PackageDev] target_format: plist, ext: tmLanguage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sublime Snippet (Raw)\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scopeName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" source.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fileTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("uuid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0da65be4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("5aac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("4b6f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("8071"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("1aadb970b8d9\n\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("YAML is not a very strict format, but can cause headaches when you don't\nknow its conventions. It supports single and double quotes, but you may also\nomit them as long as the content does not create another YAML literal. If\nthe conversion to Plist fails, take a look at the output panel for more\ninformation on the error. We'll explain later how to convert a syntax\ndefinition in YAML to Plist. This will also cover the first commented line\nin the template.")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("---")]),t._v(" and "),a("code",[t._v("...")]),t._v(" are optional.")])]),t._v(" "),a("h2",{attrs:{id:"analyzing-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#analyzing-patterns"}},[t._v("#")]),t._v(" Analyzing Patterns")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("patterns")]),t._v(" array can contain several types of element. We'll look at\nsome of them in the following sections. If you want to learn more about\npatterns, refer to Textmate's online manual.")]),t._v(" "),a("h3",{attrs:{id:"matches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#matches"}},[t._v("#")]),t._v(" Matches")]),t._v(" "),a("p",[t._v("Matches take this form:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ("),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("?")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("m)y \\s+"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Rr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("egex\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" string.format\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" This comment is optional.\n")])])]),a("p",[t._v("Sublime Text uses "),a("a",{attrs:{href:"https://github.com/kkos/oniguruma/blob/master/doc/RE",target:"_blank",rel:"noopener noreferrer"}},[t._v("Oniguruma"),a("OutboundLink")],1),t._v("'s syntax for regular expressions in\nsyntax definitions. Several existing syntax definitions make use of\nfeatures supported by this regular expression engine that aren't part of\nperl-style regular expressions, hence the requirement for Oniguruma.")]),t._v(" "),a("dl",[a("dt",[a("code",[t._v("match")])]),t._v(" "),a("dd",[t._v("A regular expression Sublime Text will use to find matches.")]),t._v(" "),a("dt",[a("code",[t._v("name")])]),t._v(" "),a("dd",[t._v("The name of the scope that should be applied to any occurrences of "),a("code",[t._v("match")]),t._v(".")]),t._v(" "),a("dt",[a("code",[t._v("comment")])]),t._v(" "),a("dd",[t._v("An optional comment about this pattern.")])]),t._v(" "),a("p",[t._v("Let's go back to our example. It looks like this:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [PackageDev] target_format: plist, ext: tmLanguage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sublime Snippet (Raw)\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scopeName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" source.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fileTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("uuid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0da65be4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("5aac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("4b6f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("8071"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("1aadb970b8d9\n\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("p",[t._v("That is, make sure the "),a("code",[t._v("patterns")]),t._v(" array is empty.")]),t._v(" "),a("p",[t._v("Now we can begin to add our rules for Sublime snippets. Let's start with\nsimple fields. These could be matched with a regex like so:")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("\\")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# or...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("\\")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$\\")]),t._v("d"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("\n")])])]),a("p",[t._v("We can then build our pattern like this:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$\\d+\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Tab stops like $1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Choosing the Right Scope Name")]),t._v(" "),a("p",[t._v("Naming scopes isn't obvious sometimes. Check the "),a("a",{attrs:{href:"https://manual.macromates.com/en/language_grammars#naming_conventions",target:"_blank",rel:"noopener noreferrer"}},[t._v("Textmate naming\nconventions"),a("OutboundLink")],1),t._v(" for guidance on scope names. "),a("Term",{attrs:{term:"PackageDev"}}),t._v(" automatically\nprovides completions for scope names according to these conventions. It\nis important to re-use the basic categories outlined there if you want\nto achieve the highest compatibility with existing colors.")],1),t._v(" "),a("p",[t._v("Color schemes have hardcoded scope names in them. They could not\npossibly include every scope name you can think of, so they target the\nstandard ones plus some rarer ones on occasion (like for CSS or\nMarkdown). This means that two color schemes using the same syntax\ndefinition may render the text differently!")]),t._v(" "),a("p",[t._v("Bear in mind too that you should use the scope name that best suits your\nneeds or preferences. It'd be perfectly fine to assign a scope like\n"),a("code",[t._v("constant.numeric")]),t._v(" to anything other than a number if you have a good\nreason to do so.")])]),t._v(" "),a("p",[t._v("And we can add it to our syntax definition too:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [PackageDev] target_format: plist, ext: tmLanguage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sublime Snippet (Raw)\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scopeName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" source.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fileTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("uuid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0da65be4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("5aac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("4b6f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("8071"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("1aadb970b8d9\n\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Tab stops like $1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$\\d+\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("You should use two spaces for indent. This is the recommended indent for\nYAML and lines up with lists like shown above.")])]),t._v(" "),a("p",[t._v("We're now ready to convert our file to "),a("code",[t._v(".tmLanguage")]),t._v(". Syntax definitions use\nTextmate's "),a("code",[t._v(".tmLanguage")]),t._v(" extension for compatibility reasons. As explained\nabove, they are simply Plist XML files.")]),t._v(" "),a("p",[t._v("Follow these steps to perform the conversion:")]),t._v(" "),a("ul",[a("li",[t._v("Make sure that "),a("code",[t._v("Automatic")]),t._v(" is selected in "),a("strong",[t._v("Tools | Build System")]),t._v(", or\nselect "),a("code",[t._v("Convert to ...")]),t._v(".")]),t._v(" "),a("li",[t._v("Press "),a("Key",{attrs:{k:"ctrl+b"}}),t._v(".\nA "),a("code",[t._v(".tmLanguage")]),t._v(" file will be generated for you in the same folder as\nyour "),a("code",[t._v(".YAML-tmLanguage")]),t._v(" file.")],1),t._v(" "),a("li",[t._v("Sublime Text will reload the changes to the syntax definition.")])]),t._v(" "),a("p",[t._v("In case you are wondering why "),a("Term",{attrs:{term:"PackageDev"}}),t._v(" knows what you want to convert your\nfile to: It's specified in the first comment line.")],1),t._v(" "),a("p",[t._v("You have now created your first syntax definition. Next, open a new file and\nsave it with the extension "),a("code",[t._v(".ssraw")]),t._v('. The buffer\'s syntax name should switch to\n"Sublime Snippet (Raw)" automatically, and you should get syntax highlighting if\nyou type '),a("code",[t._v("$1")]),t._v(" or any other simple snippet field.")]),t._v(" "),a("p",[t._v("Let's proceed to creating another rule for environment variables.")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Variables like $PARAM1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $TM_SELECTION"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("9_"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("+\n")])])]),a("p",[t._v("Repeat the above steps to update the "),a("code",[t._v(".tmLanguage")]),t._v(" file.")]),t._v(" "),a("h3",{attrs:{id:"fine-tuning-matches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fine-tuning-matches"}},[t._v("#")]),t._v(" Fine Tuning Matches")]),t._v(" "),a("p",[t._v("You might have noticed, for instance, that the entire text in "),a("code",[t._v("$PARAM1")]),t._v(" is\nstyled the same way. Depending on your needs or your personal preferences, you\nmay want the "),a("code",[t._v("$")]),t._v(" to stand out. That's where "),a("code",[t._v("captures")]),t._v(" come in. Using\ncaptures, you can break a pattern down into components to target them\nindividually.")]),t._v(" "),a("p",[t._v("Let's rewrite one of our previous patterns to use "),a("code",[t._v("captures")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Variables like $PARAM1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $TM_SELECTION"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$("),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("9_"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("+)\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("captures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.numeric.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Captures introduce complexity to your rule, but they are pretty straightforward.\nNotice how numbers refer to parenthesized groups left to right. Of course, you\ncan have as many capture groups as you want.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("Writing "),a("code",[t._v("1")]),t._v(" on a new line and pressing tab will autocomplete to "),a("code",[t._v("'1': {name: }")]),t._v(" thanks to "),a("Term",{attrs:{term:"PackageDev"}}),t._v(".")],1)]),t._v(" "),a("p",[t._v("Arguably, you'd want the other scope to be visually consistent with this one.\nGo ahead and change it too.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("As with ususal regular expressions and substitutions, the capture group\n"),a("code",[t._v("'0'")]),t._v(" applies to the whole match.")])]),t._v(" "),a("h3",{attrs:{id:"begin-end-rules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#begin-end-rules"}},[t._v("#")]),t._v(" Begin-End Rules")]),t._v(" "),a("p",[t._v("Up to now we've been using a simple rule. Although we've seen how to\ndissect patterns into smaller components, sometimes you'll want to\ntarget a larger portion of your source code that is clearly delimited by\nstart and end marks.")]),t._v(" "),a("p",[t._v("Literal strings enclosed by quotation marks or other delimiting\nconstructs are better dealt with by begin-end rules. This is a skeleton\nfor one of these rules:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("begin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("end")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n")])])]),a("p",[t._v("Well, at least in their simplest version. Let's take a look at one that\nincludes all available options:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("contentName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("begin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("beginCaptures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'0'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("end")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("endCaptures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'0'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ...")]),t._v("\n")])])]),a("p",[t._v("Some elements may look familiar, but their combination might be\ndaunting. Let's inspect them individually.")]),t._v(" "),a("dl",[a("dt",[a("code",[t._v("name")])]),t._v(" "),a("dd",[t._v("Just like with simple captures this sets the following scope name to\nthe whole match, including "),a("code",[t._v("begin")]),t._v(" and "),a("code",[t._v("end")]),t._v(" marks. Effectively,\nthis will create nested scopes for "),a("code",[t._v("beginCaptures")]),t._v(", "),a("code",[t._v("endCaptures")]),t._v("\nand "),a("code",[t._v("patterns")]),t._v(" defined within this rule. Optional.")]),t._v(" "),a("dt",[a("code",[t._v("contentName")])]),t._v(" "),a("dd",[t._v("Unlike the "),a("code",[t._v("name")]),t._v(" this only applies a scope name to the enclosed\ntext. Optional.")]),t._v(" "),a("dt",[a("code",[t._v("begin")])]),t._v(" "),a("dd",[t._v("Regex for the opening mark for this scope.")]),t._v(" "),a("dt",[a("code",[t._v("end")])]),t._v(" "),a("dd",[t._v("Regex for the end mark for this scope.")]),t._v(" "),a("dt",[a("code",[t._v("beginCaptures")])]),t._v(" "),a("dd",[t._v("Captures for the "),a("code",[t._v("begin")]),t._v(" marker. They work like captures for simple\nmatches. Optional.")]),t._v(" "),a("dt",[a("code",[t._v("endCaptures")])]),t._v(" "),a("dd",[t._v("Same as "),a("code",[t._v("beginCaptures")]),t._v(" but for the "),a("code",[t._v("end")]),t._v(" marker. Optional.")]),t._v(" "),a("dt",[a("code",[t._v("patterns")])]),t._v(" "),a("dd",[t._v("An array of patterns to match "),a("strong",[t._v("only")]),t._v(" against the begin-end's\ncontent; they aren't matched against the text consumed by "),a("code",[t._v("begin")]),t._v(" or\n"),a("code",[t._v("end")]),t._v(" themselves. Optional.")])]),t._v(" "),a("p",[t._v("We'll use this rule to style nested complex fields in snippets:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" variable.complex.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("contentName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" string.other.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("begin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'(\\$)(\\{)([0-9]+):'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("beginCaptures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.numeric.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("end")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("include")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" $self\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" support.other.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" .\n")])])]),a("p",[t._v("This is the most complex pattern we'll see in this tutorial. The "),a("code",[t._v("begin")]),t._v(" and\n"),a("code",[t._v("end")]),t._v(" keys are self-explanatory: they define a region enclosed between\n"),a("code",[t._v("${<NUMBER>:")]),t._v(" and "),a("code",[t._v("}")]),t._v(". We need to wrap the begin pattern into quotes because\notherwise the trailing "),a("code",[t._v(":")]),t._v(" would tell the parser to expect another\ndictionary key. "),a("code",[t._v("beginCaptures")]),t._v(" further divides the begin mark into smaller\nscopes.")]),t._v(" "),a("p",[t._v("The most interesting part, however, is "),a("code",[t._v("patterns")]),t._v(". Recursion, and the\nimportance of ordering, have finally made their appearance here.")]),t._v(" "),a("p",[t._v("We've seen above that fields can be nested. In order to account for this, we\nneed to style nested fields recursively. That's what the "),a("code",[t._v("include")]),t._v(" rule does\nwhen we furnish it the "),a("code",[t._v("$self")]),t._v(" value: it recursively applies our "),a("strong",[t._v("entire\nsyntax definition")]),t._v(" to the text captured by our begin-end rule. This portion\nexcludes the text individually consumed by the regexes for "),a("code",[t._v("begin")]),t._v(" and\n"),a("code",[t._v("end")]),t._v(".")]),t._v(" "),a("p",[t._v("Remember, matched text is consumed; thus, it is excluded from the next match\nattempt and can't be matched again.")]),t._v(" "),a("p",[t._v("To finish off complex fields, we'll style placeholders as strings. Since we've\nalready matched all possible tokens inside a complex field, we can safely tell\nSublime Text to give any remaining text ("),a("code",[t._v(".")]),t._v(") a literal string scope. Note\nthat this doesn't work if we made the pattern greedy ("),a("code",[t._v(".+")]),t._v(") because this\nincludes possible nested references.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("We could've used "),a("code",[t._v("contentName: string.other.ssraw")]),t._v(" instead of the last\npattern but this way we introduce the importance of ordering and how matches\nare consumed.")])]),t._v(" "),a("h3",{attrs:{id:"final-touches"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-touches"}},[t._v("#")]),t._v(" Final Touches")]),t._v(" "),a("p",[t._v("Lastly, let's style escape sequences and illegal sequences, and then we\ncan wrap up.")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sequences like \\$"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),t._v(" and \\<\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.character.escape.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\\\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$<"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Unescaped and unmatched magic characters\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" invalid.illegal.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'[$<>]'")]),t._v("\n")])])]),a("p",[t._v("The only hard thing here is not forgetting that "),a("code",[t._v("[]")]),t._v(" enclose arrays in\nYAML and thus must be wrapped in quotes. Other than that, the rules are\npretty straightforward if you're familiar with regular expressions.")]),t._v(" "),a("p",[t._v("However, you must take care to place the second rule after any others\nmatching the "),a("code",[t._v("$")]),t._v(" character, since otherwise it will be consumed and\nresult in every following expression not matching.")]),t._v(" "),a("p",[t._v("Also, even after adding these two additional rules, note that our\nrecursive begin-end rule from above continues to work as expected.")]),t._v(" "),a("p",[t._v("At long last, here's the final syntax definition:")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# [PackageDev] target_format: plist, ext: tmLanguage")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("---")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sublime Snippet (Raw)\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("scopeName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" source.ssraw\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("fileTypes")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("uuid")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 0da65be4"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("5aac"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("4b6f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("8071"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("1aadb970b8d9\n\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Tab stops like $1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$(\\d+)\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("captures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.numeric.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Variables like $PARAM1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" $TM_SELECTION"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\$("),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("Za"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("z0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v("9_"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("+)\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("captures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.numeric.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" variable.complex.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("begin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'(\\$)(\\{)([0-9]+):'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("beginCaptures")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" keyword.other.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("'3'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.numeric.ssraw"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("end")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("patterns")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("include")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" $self\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" support.other.ssraw\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" .\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sequences like \\$"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),t._v(" and \\<\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" constant.character.escape.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" \\\\"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$<"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("comment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Unescaped and unmatched magic characters\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" invalid.illegal.ssraw\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'[$<>]'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v("\n")])])]),a("p",[t._v('There are more available constructs and code reuse techniques using a\n"repository", but the above explanations should get you started with the\ncreation of syntax definitions.')]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("If you previously used JSON for syntax definitions you are still able to do\nthis because "),a("Term",{attrs:{term:"PackageDev"}}),t._v(" is backwards compatible.")],1),t._v(" "),a("p",[t._v("If you want to consider switching to YAML (either from JSON or directly from\nPlist), it provides a command named "),a("code",[t._v("PackageDev: Convert to YAML and Rearrange Syntax Definition")]),t._v(" which will automatically format the resulting\nYAML in a pleasurable way.")])])])}),[],!1,null,null,null);e.default=n.exports}}]);